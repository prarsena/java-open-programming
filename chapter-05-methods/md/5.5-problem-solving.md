# 5.5 Problem Solving with Methods

The primary goal of methods is to simplify complex programs.

## Functional Decomposition

The process of breaking a large, complex problem down into smaller, more manageable sub-problems is called **functional decomposition** or sometimes the "divide and conquer" method.

Each sub-problem is solved by a separate method, making the overall program easier to design, code, debug, and maintain. The `main` method often serves as the orchestrator, calling the various sub-methods in the correct sequence to execute the complete program logic.

**Example: Functional Decomposition**

```java
import java.util.Scanner;

public class StudentInfo {
    public static void main(String[] args) {
        String studentName = getStudentName();
        double score = getStudentScore(studentName);
        char grade = calculateGrade(score);
        displayGradeReport(studentName, score, grade);
    }

    public static String getStudentName(){
        Scanner kbd = new Scanner(System.in);
        System.out.println("Type in your name: ");
        String name = kbd.nextLine();
        kbd.close();
        return name;
    }

    public static double getStudentScore(String studentName){
        double score; 
        if (studentName.equalsIgnoreCase("Jackson")){
            score = 88;
        }
        else if (studentName.equalsIgnoreCase("Molly")){
            score = 96;
        }
        else if (studentName.equalsIgnoreCase("Peter")){
            score = 52;
        }
        else {
            score = 82;
        }
        return score;
    }

    public static char calculateGrade(double score){
        char grade;
        if (score > 90){
            grade = 'A';
        } 
        else if (score > 80){
            grade = 'B';
        }
        else if (score > 70){
            grade = 'C';
        }
        else if (score > 60){
            grade = 'D';
        }
        else {
            grade = 'F';
        }
        return grade;
    }

    public static void displayGradeReport(String studentName, double score, char grade){
        System.out.println("Student name: " + studentName);
        System.out.println("Student score: " + score);
        System.out.println("Student grade: " + grade);
    }
}

```

## Calling Methods That Throw Exceptions

When a method performs an operation that might fail (such as file input/output), Java requires that the method either handle the unexpected event (an **exception**) or declare that it throws the exception.

If Method A calls Method B, and Method B is defined to `throw` an exception (like `FileNotFoundException` or `IOException`) because it interacts with the file system, Method A must also declare that it `throws` the same exception or handle it using a `try-catch` block.

## Example 5.5.2: Exception Propagation

```java
// Method that interacts with external resources (files), requiring throws IOException
public static void readFileData() throws IOException {
    // Code here uses Scanner/File/PrintWriter, which might throw an IOException
}

public static void main(String[] args) throws IOException { 
    // Main must also declare 'throws IOException' or handle it, 
    // since it calls readFileData().
    readFileData(); // This call forces main to declare the exception
    System.out.println("Data processed successfully.");
}
```

### Check Your Understanding (5.5)
1. What is the goal of functional decomposition?
2. If a method attempts to open a file for reading, why must its header often include a `throws IOException` clause?
3. If Method A calls Method B, and Method B throws an exception, what are the two required ways Method A can address this exception?

### Practice Problems (5.5)
1. Imagine a large banking application. Outline three distinct sub-problems that could be solved using separate methods (e.g., input validation).
2. Write the method header for a `main` method that calls a static method named `saveLog` that is known to throw an `IOException`.
