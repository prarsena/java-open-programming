# 5.5 Problem Solving with Methods

The primary goal of methods is to simplify complex programs.

## Functional Decomposition

The process of breaking a large, complex problem down into smaller, more manageable sub-problems is called **functional decomposition** or sometimes the "divide and conquer" method.

Each sub-problem is solved by a separate method, making the overall program easier to design, code, debug, and maintain. The `main` method often serves as the orchestrator, calling the various sub-methods in the correct sequence to execute the complete program logic.

**Example: Functional Decomposition**

```java
public class GradeReport {
    void main() {
            String studentName = getStudentName();
            double score = getStudentScore(studentName);
            char grade = calculateGrade(score);
            displayGradeReport(studentName, score, grade);
        }

        String getStudentName(){
            return IO.readln("Type in your name: ");
        }

        double getStudentScore(String studentName){
            return switch (studentName.toLowerCase()) {
                case "jackson" -> 88;
                case "molly" -> 96;
                case "peter" -> 52;
                default -> 82;
            };
        }

        char calculateGrade(double score){
            char grade;
            if (score > 90){
                grade = 'A';
            } 
            else if (score > 80){
                grade = 'B';
            }
            else if (score > 70){
                grade = 'C';
            }
            else if (score > 60){
                grade = 'D';
            }
            else {
                grade = 'F';
            }
            return grade;
        }

        void displayGradeReport(String studentName, double score, char grade){
            IO.println("Student name: " + studentName);
            IO.println("Student score: " + score);
            IO.println("Student grade: " + grade);
        }
    }
```

## Calling Methods That Throw Exceptions

When a method performs an operation that might fail (such as file input/output), Java requires that the method either handle the unexpected event (an **exception**) or declare that it throws the exception.

If Method A calls Method B, and Method B is defined to `throw` an exception (like `FileNotFoundException` or `IOException`) because it interacts with the file system, Method A must also declare that it `throws` the same exception or handle it using a `try-catch` block.

## Example 5.5.2: Exception Propagation

```java
public class ExceptionDemo {
    void readFileData() throws IOException {
        // Code here uses Scanner/File/PrintWriter, which might throw an IOException
    }

    void main() throws IOException { 
        // Main must also declare 'throws IOException' or handle it, 
        // since it calls readFileData().
        readFileData(); // This call forces main to declare the exception
        IO.println("Data processed successfully.");
    } declare the exception
    IO.println("Data processed successfully.");
}
```

### Check Your Understanding (5.5)
1. What is the goal of functional decomposition?
2. If a method attempts to open a file for reading, why must its header often include a `throws IOException` clause?
3. If Method A calls Method B, and Method B throws an exception, what are the two required ways Method A can address this exception?

### Practice Problems (5.5)
1. Imagine a large banking application. Outline three distinct sub-problems that could be solved using separate methods (e.g., input validation).
2. Write the method header for a `main` method that calls a static method named `saveLog` that is known to throw an `IOException`.
