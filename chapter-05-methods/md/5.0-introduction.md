In the previous chapter, we extended our control flow capabilities by implementing **loops** (such as `while`, `do-while`, and `for`) to execute blocks of code repeatedly and by introducing **File I/O** for saving and retrieving data persistently. 

Now we will transition from controlling *when* statements execute to mastering *how* to organize them efficiently through **methods**.

## What are Methods?

Methods are **reusable collections of statements** that perform specific tasks, enabling essential programming principles:

- **Functional decomposition** (breaking large problems into smaller, manageable pieces)
- **Code reuse**

### What you will learn

In this chapter, you will learn how to:
- Understand the role of methods in functional decomposition and code reuse
- Distinguish between **void** methods and **value-returning** methods
- Define a method using a method header (signature) and a body
- Understand the role of modifiers, particularly **static** and **instance** methods
- Pass arguments (values) to a method's parameters
- Understand the difference between **passing by value** (for primitives) and **passing object references**
- Manage **local variables**, including their scope and lifetime
- Return values and object references from methods
- Use methods for effective problem solving (functional decomposition)