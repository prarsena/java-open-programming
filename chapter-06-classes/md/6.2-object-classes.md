# 6.2 Writing an Object Class: Fields, Accessors, and Data Hiding

A high-quality Object Class prioritizes **data hiding** to ensure data integrity. This is achieved by making the data fields private and only allowing manipulation through public methods.

## Data Hiding and the `private` Keyword

**Instance fields** are the data components of an object. Good object-oriented programming practice dictates making all of a classâ€™s fields **private**.

The **`private`** keyword is an access modifier that restricts access to the field only to methods **within the same class**. This prevents external classes (like our `TestCar.java` from Section 6.1) from directly accessing or corrupting the object's internal state.

## Accessor (Getter) and Mutator (Setter) Methods

Since the fields are private, we need controlled pathways for other code to interact with the data:

- **Accessor Method (Getter):** A public, **value-returning** instance method used to **retrieve** (get) the value of a private field.
- **Mutator Method (Setter):** A public, typically **`void`** instance method used to **modify** (set) the value of a private field. Mutator methods are often used to implement input validation.

**Example 6.2: Designing a Song Class with Data Hiding**

```java
// Song.java (Object Class/Blueprint demonstrating data control)
public class Song {
    // Private Instance Fields (Data Hiding)
    private String title;
    // Volume level must stay between 0 (silent) and 100 (max).
    private int volumeLevel; 
    // Duration of the song in seconds. Note: No setter method.
    private int durationSeconds;

    // --- MUTATOR (SETTER) METHODS ---
    
    // Setter for title. Note the use of 'this' to avoid shadowing.
    public void setTitle(String title) {
        this.title = title;
    }

    // Setter for volumeLevel, including validation logic using if-else-if.
    public void setVolumeLevel(int level) {
        // Check if level is too low
        if (level < 0) { 
            this.volumeLevel = 0;
        } 
        // Check if level is too high
        else if (level > 100) { 
            this.volumeLevel = 100;
        } 
        // If valid, set the level
        else {
            this.volumeLevel = level;
        }
    }

    // --- ACCESSOR (GETTER) METHODS ---
    public String getTitle() {
        return title;
    }

    public int getVolumeLevel() {
        return volumeLevel;
    }
    
    public int getDurationSeconds() {
        return durationSeconds;
    }

    // Instance Method (Behavior that modifies the object's state)
    public void increaseVolume() {
        System.out.println(title + " volume boosted by 15!");
        // We use the setter to update the state, which automatically ensures 
        // the new level does not exceed the maximum of 100.
        setVolumeLevel(this.volumeLevel + 15);
        System.out.println("New volume level: " + this.volumeLevel);
    }
}
```

## The `this` Reference

When a method parameter has the same name as an instance field (e.g., `setTitle(String title)`), this causes **shadowing**. The local parameter takes precedence. 

The **`this` reference variable** explicitly refers to the object's instance field, resolving this ambiguity. Example: `this.title = title;`

## Avoiding Stale Data

You should avoid storing calculated data (e.g., area, age, total price) in a field if that data depends on other fields that can change. If the source data changes, the calculated value becomes **stale data**.

To prevent this, perform the calculation within a public instance method every time the value is requested.

```java
// Calculated Method Example for a Song (Calculates duration in minutes)
public double getDurationMinutes() {
    // Assuming private field int durationSeconds exists
    return (double)durationSeconds / 60.0;
}
```

#### Check Your Understanding (6.2)

1. What is the fundamental goal of declaring instance fields as `private`?
2. Which type of method, accessor or mutator, is usually responsible for validating input data?
3. Why should a `Rectangle` object have a `getArea()` method that calculates the area dynamically, rather than storing the area in a private field?

#### Practice Problems (6.2)

1. **Setter Implementation (Music):** A `Song` class has a private field `int playCount`. Write a public mutator method `incrementPlayCount()` that increases `playCount` by exactly one. (No parameter needed.)
2. **Getter Implementation (Car):** A `Car` class has a private field `boolean isAvailable`. Write the corresponding public accessor method `isAvailable()`.