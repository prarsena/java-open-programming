# 6.6 Advanced Object Behavior: `toString()` and `equals()`

All classes implicitly inherit methods from the foundational `Object` class. Two crucial methods we often **override** are `toString()` and `equals()`.

## Customizing `toString()`

By default, the inherited `toString()` method returns a string showing the class name and the object's memory location (hash code, e.g., `Car@xxxxx`). This occurs whenever you print an object reference using `System.out.println()`.

To make the output useful, we typically **override** `toString()` to return a descriptive string containing the values of the object's instance fields.

**Example 6.6a: Overriding `toString()` for a Pet**

```java
public class Pet {
    private String name;
    private String species;
    // ... constructor, fields, etc. ...

    @Override
    public String toString() {
        return "Pet Instance: Name=" + name + ", Species=" + species;
    }
}
// In main:
// Pet poodle = new Pet("Fido", "Poodle");
// IO.println(poodle);
// Output: Pet Instance: Name=Fido, Species=Poodle
```

## Customizing `equals()` for Content Comparison

The default `equals()` method compares two object references based on their **memory locations**, just like the `==` operator. It determines if two references point to the _exact same_ object in memory.

If you want to define equality based on the objects' **content** (e.g., two different `Song` objects are "equal" if they share the same title and artist), you must **override** the `equals()` method.

**Example 6.6b: Defining Song Equality (Music)**

```java
public class Song {
    private String title;
    private String artist;
    // ...

    // Custom method to compare contents
    public boolean equals(Song otherSong) {
        // Compare titles AND artists for equality
        if (this.title.equals(otherSong.title) &&
            this.artist.equals(otherSong.artist)) {
            return true;
        } else {
            return false;
        }
    }
}
```

Note that we use the `String.equals()` method inside our custom `Song.equals()` method because strings are non-primitive objects and must be compared by content.

#### Check Your Understanding (6.6)

1. When is the `toString()` method implicitly called in Java?
2. If `carA` and `carB` are two different `Car` objects created independently but initialized with the same make and model, what will the default `equals()` method return, and why?
3. In `Song.equals(Song otherSong)`, why must we use `this.title.equals(otherSong.title)` instead of `this.title == otherSong.title`?

#### Practice Problems (6.6)

1. **`toString()` implementation (Car):** Write a custom `toString()` method for the `Car` class that prints the car's make and year in a readable format.
2. **`equals()` Logic:** You are designing a `Pet` class where two pets are considered equal if they have the same `String species`. Write the basic logic for the custom `equals(Pet otherPet)` method.