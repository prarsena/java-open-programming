In previous chapters, we mastered procedural programming by controlling the flow of instructions using decision structures (Chapter 3) and repetition (Chapter 4), and organizing reusable code into methods (Chapter 5). This process, known as **functional decomposition**, helped us break down large problems into smaller, manageable sub-problems.

Now, we shift our focus entirely to **Object-Oriented Programming (OOP)**, which is the defining approach of the Java language. OOP revolves around organizing data (fields) and operations (methods) together into self-contained software components called **objects**.

This chapter provides the blueprint for building those objects by introducing the concept of a **Class**.


## What you will learn 

In this chapter, you will learn how to:

- Understand the relationship between **classes (blueprints)** and **objects (instances)**.
- Differentiate between executable classes and object classes.
- Define a class structure using **instance fields** and **instance methods**.
- Implement **data hiding** using the `private` access specifier.
- Create public **accessor (getter)** and **mutator (setter)** methods to manage private data.
- Differentiate between **static** (class) methods and **instance** (object) methods.
- Define and use **constructors** (including no-arg and parameterized) to initialize objects.
- Use method and constructor **overloading** to provide flexibility.
- Pass objects as arguments to methods and understand how **references** are handled.
- Override the default `toString()` and `equals()` methods for custom object behavior.
- Understand object design principles, including packages and scope.