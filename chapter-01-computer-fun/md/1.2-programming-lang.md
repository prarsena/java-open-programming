# 1.2 Programming Languages
Programming languages are used to write applications, including operating systems. 

We can divide programming languages into two categories. 

- **Low-level programming languages** interact closely with the hardware. Examples include Assembly, C, and C++. 
- **High-level programming languages** interact with the operating system (rather than the hardware). Examples include Java, Python, C#, Swift, and JavaScript. These languages are more human-readable and provide many developer experience advantages over low-level languages.

## Low-level languages
**Low-level (or systems) programming languages** interact with the physical components of the computer, like the CPU, memory, and I/O devices. They are "low" in the sense of being close to the hardware, not in the sense of "low complexity." Because of this, systems programmers must be aware of the underlying hardware architecture. Code written for one architecture (e.g., x86) may not be compatible with another (e.g., ARM) without significant modification. 

As you could imagine, low-level languages are also the oldest programming languages.

- **Assembly languages** were invented in the **late 1940s and early 1950s**. When you write a program in an assembly language, it is translated into machine code by an **assembler**. Because each assembly language is specific to a particular procesor, the code written for one machine cannot run on another. 
- The **C programming language** was devised in the early **1970s** by Dennis Ritchie at Bell Laboratories. C made significant improvements over assembly by introducing higher-level datatypes and features that enhanced productivity and portability. C programs can compile to assembly code or directly to machine code by a C **compiler**.  
- **C++** was invented by Bjarne Stroustrup at AT&T Bell Labs in **1979**. It originated as "C with Classes," designed to extend the C language with object-oriented programming features. The name was changed to C++ in 1983. Like C, it uses a compiler to generate machine code. 

The C and C++ languages are human-readable but are full of mysterious concepts and references. They often require specialized manuals to tell you the meaning of each value. Assembly languages are not human readable, but can include comments to help programmers keep track of the operations.

However, the major benefit to using low-level languages is that they are fast and efficient. If you need to execute millions of requests per second, highly optimized code can save you millions of dollars in computing resources. 

## Low-level code samples
Earlier we said that a computer's purpose is to help us achieve our goals. Let's imagine we're application developers at a bank. While we develop an app, we want to keep track of how many times we tried to run it. This helps with debugging, monitoring, and auditing. We can develop a small script that record events, errors, or just confirmation of its operations. 

Assume we're free to use any programming language to develop this application logging script. Let's see how it might look in different low-level languages. 

Let's start with the lowest level language.

### Assembly
Assembly code (specifically, Netwide Assembly (NASM) for Linux) looks like this: 

```armasm
section .data
    filename db "application.log", 0
    message db "INFO: Operation completed successfully.", 0x0A
    msg_len equ $ - message

section .text
    global _start

_start:
    mov rax, 2
    lea rdi, [rel filename]
    mov rsi, 0o1002
    mov rdx, 0o644
    syscall
    mov rbx, rax

    mov rax, 1
    mov rdi, rbx
    lea rsi, [rel message]
    mov rdx, msg_len
    syscall

    mov rax, 3
    mov rdi, rbx
    syscall

    mov rax, 60
    xor rdi, rdi
    syscall
```

This code is incomprehensible without comments, but it does what we need: loads (or creates) a log file into memory, writes the message, and closes the file. It interacts directly with the operating system through system calls (`syscall`) and doesn't require any extra libraries. 

> ðŸ”­ **Keep Exploring!** Paste the assembly code into your favorite LLM and ask it to explain each line. 

### C
Here's how the script might look written in the C programming language:

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    FILE *file_ptr;
    time_t rawtime;
    struct tm *info;
    char timestamp[20];
    
    time(&rawtime);
    info = localtime(&rawtime);
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", info);
    
    file_ptr = fopen("application.log", "a");
    if (file_ptr == NULL) {
        perror("Error opening log file");
        return EXIT_FAILURE;
    }
    
    fprintf(file_ptr, "[%s] INFO: Operation completed successfully.\n", timestamp);
    fclose(file_ptr);
    printf("Logged message to application.log\n");
    return EXIT_SUCCESS;
}
```

There are some obscure symbols and abbreviations, but it's at least human-readable. It does what the assembly code does, but it adds error handling in case the file can't be opened. It also prepends a timestamp to each message so we know exactly when the script was run. 

> ðŸ§­ **Keep Exploring!** Paste the C code into your favorite LLM and ask it to interpret it line-by-line for you.

One difference from Assembly is that C uses `#include` statements to bring portable libraries into your code. These library functions wrap the complex, OS-specific system calls. For example, when you call `fopen("application.log", "a")`, the `fopen` library function determines what underlying system calls are necessary for that specific operating system.

### C++
Here's how the script might look written in the C++ programming language:

```cpp
#include <fstream>
#include <iostream>
#include <string>
#include <chrono>
#include <iomanip>

int main() {
    std::ofstream output_file("application.log", std::ios::app);
    if (!output_file.is_open()) {
        std::cerr << "Error: Could not open log file application.log\n";
        return 1;
    }

    auto now = std::chrono::system_clock::now();
    auto in_time_t = std::chrono::system_clock::to_time_t(now);

    output_file << "[" << std::put_time(std::localtime(&in_time_t), "%Y-%m-%d %H:%M:%S") << "] INFO: Operation completed successfully." << std::endl;
    output_file.close();
    std::cout << "Logged message to application.log\n";
    return 0;
}
```

The C++ code is similar to C, but achieves the same functionality in fewer lines of code. It also adds benefits in terms of safety and design. 

C++, like Java, uses **objects** to represent data. You don't directly manipulate the raw data that comprises a file, for example. Instead, you interact with a **file object**. This object acts as a structured interface, providing a safer way to perform operations. This means there is less opportunity for programmers to accidentally misuse low-level pointers or memory, which can lead to crashes or security vulnerabilities in C or Assembly.

## High-level languages
**High-level programming languages** interact with the operating system (rather than the hardware) either through an **interpreter** or a **compiled by a virtual machine**. 

They are sometimes called **abstraction languages**, because they abstract away the lower-level details like memory management and system calls. They are extremely portable and provide many advantages for developer productivity.

### Interpreted Languages
**Interpreted languages**, like **Python**, **Ruby**, and early versions of **JavaScript**, don't get fully compiled into machine code before execution. Instead, a program called an **interpreter** reads and executes the code line by line at runtime.

The interpreter itself is a program written in a lower-level language (like C or C++) that runs directly on the operating system. When you execute a Python script, for example, the Python interpreter starts up, reads your script, and translates each line into actions that the OS can understand (e.g., allocating memory, writing to a file, performing calculations).

### Virtual Machine (VM) Based Languages
Languages like **Java** and **C#** are designed to run on a **virtual machine**. These languages are typically compiled into an **intermediate bytecode** rather than directly into machine code. The bytecode is then executed by a virtual machine. The VM acts as a runtime environment that translates the bytecode into native machine instructions for the underlying operating system. 

The VM itself is an application that runs on the operating system. It requests resources from the OS, similar to how an interpreter does. The key difference is that the VM provides a consistent environment for the bytecode, abstracting away the specifics of the underlying OS. 

### JavaScript
JavaScript has had a unique execution journey that deserves separate mention.

JavaScript began primarily as a language for web browsers, where it was **interpreted**. The browser's JavaScript engine would parse and execute the code directly, line by line, allowing for dynamic, interactive web pages.

However, modern JavaScript environments, including current web browsers (like Chrome's V8 engine and Firefox's SpiderMonkey) and server-side runtimes like **Node.js**, now use a **hybrid execution model**. They typically start by parsing JavaScript into an intermediate form and running it in an **interpreter** for fast startup. 

The engine then employs sophisticated **Just-In-Time (JIT) compilers** to translate frequently executed parts of the JavaScript code directly into highly optimized native machine code. This compilation happens during runtime, allowing modern JavaScript applications to achieve performance levels far exceeding what pure interpretation could offer.

## High-level code samples

### Java
We'll be learning many of these concepts in this course! 

Here is the same logger script from above, written in Java:

```java
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class AppLogger {
    public static void main(String[] args) {
        String fileName = "application.log";
        String logMessage = "INFO: Operation completed successfully.";

        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String timestamp = now.format(formatter);

        try (FileWriter writer = new FileWriter(fileName, true)) {
            writer.write(String.format("[%s] %s%n", timestamp, logMessage));
            System.out.println("Logged message to " + fileName);
        } catch (IOException e) {
            System.err.println("An error occurred while writing to the log file: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

### Python
Here's the script in Python:

```python
import datetime

file_name = "application.log"
log_message = "INFO: Operation completed successfully."

current_time = datetime.datetime.now()
timestamp = current_time.strftime("%Y-%m-%d %H:%M:%S")

try:
    with open(file_name, "a") as file:
        file.write(f"[{timestamp}] {log_message}\n")
    print(f"Logged message to {file_name}")
except IOError as e:
    print(f"Error writing to log file {file_name}: {e}")

```

### JavaScript
Here's the script in JavaScript:

```javascript
const fs = require('fs');

const fileName = 'application.log';
const logMessage = 'INFO: Operation completed successfully.';

const now = new Date();
const timestamp = now.getFullYear() + '-' +
                  String(now.getMonth() + 1).padStart(2, '0') + '-' +
                  String(now.getDate()).padStart(2, '0') + ' ' +
                  String(now.getHours()).padStart(2, '0') + ':' +
                  String(now.getMinutes()).padStart(2, '0') + ':' +
                  String(now.getSeconds()).padStart(2, '0');

const logEntry = `[${timestamp}] ${logMessage}\n`;

fs.appendFile(fileName, logEntry, (err) => {
    if (err) {
        console.error('Error writing to log file:', err);
    } else {
        console.log(`Logged message to ${fileName}`);
    }
});
```
